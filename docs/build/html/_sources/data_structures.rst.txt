.. _implementations-data_structures:

===============
Data Structures
===============

When analyzing financial data, unstructured datasets are commonly transformed into a structured format referred to as bars, where a bar represents a row in a table.
mlfinlab implements tick, volume, and dollar bars using traditional standard bar methods as well as the less common information driven bars. 


Data Preparation
================

Read in our data::

	# Required Imports
	import numpy as np
	import pandas as pd


	data = pd.read_csv('FILE_PATH')

Format Data
~~~~~~~~~~~

In order to utilize the bar sampling methods presented below, our data must first be formatted properly.
Many data vendors will let you choose the format of your raw tick data files. We want to only focus on the following 3 columns: date_time, price, volume. The reason for this is to minimise the size of the csv files and the amount of time when reading in the files.

Our data is sourced from TickData LLC which provide TickWrite 7, to aid in the formatting of saved files. This allows us to save csv files in the format date_time, price, volume.

For this tutorial we will assume that you need to first do some preprocessing and then save your data to a csv file::


	# Format the Data

	# Don't convert to datetime here, it will take forever to convert
	date_time = data['Date'] + ' ' + data['Time']
	new_data = pd.concat([date_time, data['Price'], data['Volume']], axis=1)
	new_data.columns = ['date', 'price', 'volume']


Initially, your instinct may be to pass mlfinlab package an in-memory DataFrame object but the truth is when you're running the function in production, your raw tick data csv files will be way too large to hold in memory. We used the subset 2011 to 2019 and it was more than 25 gigs. It is for this reason that the mlfinlab package requires a file path to read the raw data files from disk::

	# Save to csv
	new_data.to_csv('FILE_PATH', index=False)



Standard Bars
=============

The three standard bar methods implemented share a similiar underlying idea in that we want to sample a bar after a certain threshold is reached.

For tick bars, we sample a bar after a certain number of ticks.

For volume bars, we sample a bar after a certain volume amount is traded.

For dollar bars, we sample a bar after a certain dollar amount is traded.

These bars are used throughout the text book (Advances in Financial Machine Learning, By Marcos Lopez de Prado, 2018,
pg 25) to build the more interesting features for predicting financial time series data.

Tick Bars
~~~~~~~~~

.. function:: get_tick_bars(file_path, threshold=2800, batch_size=20000000, verbose=True, to_csv=False, output_path=None)

	:param file_path: File path pointing to csv data.
	:param threshold: A cumulative value above this threshold triggers a sample to be taken.
	:param batch_size: The number of rows per batch. Less RAM = smaller batch size.
	:param verbose: Print out batch numbers (True or False)
	:param to_csv: Save bars to csv after every batch run (True or False)
	:param output_path: Path to csv file, if to_csv is True
	:return: Dataframe of tick bars

Creates the tick bars: date_time, open, high, low, close.

The get_tick_bars function can be implemented as follows::
	
	from mlfinlab.data_structures import standard_data_structures


	# Tick Bars
	tick = standard_data_structures.get_tick_bars('FILE_PATH', threshold=5500, 
	batch_size=1000000, verbose=False)


Volume Bars
~~~~~~~~~~~

.. function:: get_volume_bars(file_path, threshold=28224, batch_size=20000000, verbose=True, to_csv=False, output_path=None)

	:param file_path: File path pointing to csv data.
	:param threshold: A cumulative value above this threshold triggers a sample to be taken.
	:param batch_size: The number of rows per batch. Less RAM = smaller batch size.
	:param verbose: Print out batch numbers (True or False)
	:param to_csv: Save bars to csv after every batch run (True or False)
	:param output_path: Path to csv file, if to_csv is True
	:return: Dataframe of volume bars

Creates the volume bars: date_time, open, high, low, close.

The get_volume_bars function can be implemented as follows::
	
	from mlfinlab.data_structures import standard_data_structures

	
	# Volume Bars
	volume = standard_data_structures.get_volume_bars('FILE_PATH', threshold=28000, 
	batch_size=1000000, verbose=False)

Dollar Bars
~~~~~~~~~~~

.. function:: get_dollar_bars(file_path, threshold=70000000, batch_size=20000000, verbose=True, to_csv=False, output_path=None)

	:param file_path: File path pointing to csv data.
	:param threshold: A cumulative value above this threshold triggers a sample to be taken.
	:param batch_size: The number of rows per batch. Less RAM = smaller batch size.
	:param verbose: Print out batch numbers (True or False)
	:param to_csv: Save bars to csv after every batch run (True or False)
	:param output_path: Path to csv file, if to_csv is True
	:return: Dataframe of dollar bars

Creates the dollar bars: date_time, open, high, low, close.

The get_dollar_bars function can be implemented as follows::
	
	from mlfinlab.data_structures import standard_data_structures

	
	# Dollar Bars
	dollar = standard_data_structures.get_dollar_bars('FILE_PATH', threshold=70000000, 
	batch_size=1000000, verbose=True)



Information-Driven Bars
=======================

Information-driven bars are based on the notion of sampling a bar when new information arrives to the market. The two types of information-driven bars implemented are imbalance bars and run bars. For each type, tick, volume, and dollar bars are included.


Imbalance Bars
~~~~~~~~~~~~~~

Imbalance bars are described below in the context of tick imbalance bars, however, this concept can be extended to volume as well as dollar imbalance bars.

The idea behind imbalance bars is we want to sample a bar whenever imbalance exceeds our expectations.

We define imbalance as the cumulative sum of ticks where a tick can have a value of 1, 0 or -1. 

If the change in price associated with a tick is positive, the tick receives a value of 1 and vice versa.

If there is no change in price, the tick receives a value of 0.

We define our expectation as the expected size of our tick bar multiplied by the absolute value of the probability that a tick is a 1 minus the probability that a tick is a -1.

The expected size of our tick bar is an EWMA of our previous tick bar sizes. 

Initially, the expected size of our tick bar is arbitrarily chosen as we do not have a previous bar to reference.

Additionally, the probability that a tick is a 1 or -1, is an EWMA of previous tick values.

In order to sample a bar, either the current imbalance must be greater than the average imbalance, or more ticks must be used than were used previosuly on average to sample a bar.

Implementations of imbalance bars can be seen below:


.. function:: get_tick_imbalance_bars(file_path, num_prev_bars, exp_num_ticks_init=100000, batch_size=2e7, verbose=True, to_csv=False, output_path=None)

    :param file_path: File path pointing to csv data.
    :param num_prev_bars: Number of previous bars used for EWMA window expected # of ticks
    :param exp_num_ticks_init: initial expected number of ticks per bar
    :param batch_size: The number of rows per batch. Less RAM = smaller batch size.
    :param verbose: Print out batch numbers (True or False)
    :param to_csv: Save bars to csv after every batch run (True or False)
    :param output_path: Path to csv file, if to_csv is True
    :return: DataFrame of tick bars

Creates the tick imbalance bars: date_time, open, high, low, close.

The get_tick_imbalance_bars function can be implemented as follows::
	
	from mlfinlab.data_structures import imbalance_data_structures

	
	# Tick Imbalance Bars
	tick_imbalance = imbalance_data_structures.get_tick_imbalance_bars('FILE_PATH', 
	num_prev_bars=3, exp_num_ticks_init=100000)




.. function:: get_volume_imbalance_bars(file_path, num_prev_bars, exp_num_ticks_init=100000, batch_size=2e7, verbose=True, to_csv=False, output_path=None)

    :param file_path: File path pointing to csv data.
    :param num_prev_bars: Number of previous bars used for EWMA window expected # of ticks
    :param exp_num_ticks_init: initial expected number of ticks per bar
    :param batch_size: The number of rows per batch. Less RAM = smaller batch size.
    :param verbose: Print out batch numbers (True or False)
    :param to_csv: Save bars to csv after every batch run (True or False)
    :param output_path: Path to csv file, if to_csv is True
    :return: DataFrame of volume bars

Creates the volume imbalance bars: date_time, open, high, low, close.

The get_volume_imbalance_bars function can be implemented as follows::
	
	from mlfinlab.data_structures import imbalance_data_structures

	
	# Volume Imbalance Bars
	volume_imbalance = imbalance_data_structures.get_volume_imbalance_bars('FILE_PATH', 
	num_prev_bars=3, exp_num_ticks_init=100000)


.. function:: get_dollar_imbalance_bars(file_path, num_prev_bars, exp_num_ticks_init=100000, batch_size=2e7, verbose=True, to_csv=False, output_path=None)

    :param file_path: File path pointing to csv data.
    :param num_prev_bars: Number of previous bars used for EWMA window expected # of ticks
    :param exp_num_ticks_init: initial expected number of ticks per bar
    :param batch_size: The number of rows per batch. Less RAM = smaller batch size.
    :param verbose: Print out batch numbers (True or False)
    :param to_csv: Save bars to csv after every batch run (True or False)
    :param output_path: Path to csv file, if to_csv is True
    :return: DataFrame of dollar bars

Creates the dollar imbalance bars: date_time, open, high, low, close.

The get_dollar_imbalance_bars function can be implemented as follows::
	
	from mlfinlab.data_structures import imbalance_data_structures

	
	# Dollar Imbalance Bars
	dollar = imbalance_data_structures.get_dollar_bars('FILE_PATH', 
	num_prev_bars=3, exp_num_ticks_init=100000)

Run Bars
~~~~~~~~

Run bars share the same mathematical structure as imblance bars, however, instead of looking at each individual trade, we are looking at sequences of trades in the same direction. The idea is that we are trying to detect order flow imbalance caused by actions such as large traders sweeping the order book or iceberg orders.

Implementations of run bars can be seen below:

.. function:: get_tick_run_bars(file_path, num_prev_bars, exp_num_ticks_init=100000, batch_size=2e7, verbose=True, to_csv=False, output_path=None)

    :param file_path: File path pointing to csv data.
    :param num_prev_bars: Number of previous bars used for EWMA window expected # of ticks
    :param exp_num_ticks_init: initial expected number of ticks per bar
    :param batch_size: The number of rows per batch. Less RAM = smaller batch size.
    :param verbose: Print out batch numbers (True or False)
    :param to_csv: Save bars to csv after every batch run (True or False)
    :param output_path: Path to csv file, if to_csv is True
    :return: DataFrame of tick bars

Creates the tick run bars: date_time, open, high, low, close.

The get_tick_run_bars function can be implemented as follows::
	
	from mlfinlab.data_structures import run_data_structures

	
	# Tick Run Bars
	tick_run = run_data_structures.get_tick_run_bars('FILE_PATH', 
	num_prev_bars=3, exp_num_ticks_init=100000)


.. function:: get_volume_run_bars(file_path, num_prev_bars, exp_num_ticks_init=100000, batch_size=2e7, verbose=True, to_csv=False, output_path=None)

    :param file_path: File path pointing to csv data.
    :param num_prev_bars: Number of previous bars used for EWMA window expected # of ticks
    :param exp_num_ticks_init: initial expected number of ticks per bar
    :param batch_size: The number of rows per batch. Less RAM = smaller batch size.
    :param verbose: Print out batch numbers (True or False)
    :param to_csv: Save bars to csv after every batch run (True or False)
    :param output_path: Path to csv file, if to_csv is True
    :return: DataFrame of volume bars

Creates the volume run bars: date_time, open, high, low, close.

The get_volume_run_bars function can be implemented as follows::
	
	from mlfinlab.data_structures import run_data_structures

	
	# Volume Run Bars
	volume_run = run_data_structures.get_volume_run_bars('FILE_PATH', 
	num_prev_bars=3, exp_num_ticks_init=100000)



.. function:: get_dollar_run_bars(file_path, num_prev_bars, exp_num_ticks_init=100000, batch_size=2e7, verbose=True, to_csv=False, output_path=None)

    :param file_path: File path pointing to csv data.
    :param num_prev_bars: Number of previous bars used for EWMA window expected # of ticks
    :param exp_num_ticks_init: initial expected number of ticks per bar
    :param batch_size: The number of rows per batch. Less RAM = smaller batch size.
    :param verbose: Print out batch numbers (True or False)
    :param to_csv: Save bars to csv after every batch run (True or False)
    :param output_path: Path to csv file, if to_csv is True
    :return: DataFrame of dollar bars

Creates the dollar run bars: date_time, open, high, low, close.

The get_dollar_run_bars function can be implemented as follows::
	
	from mlfinlab.data_structures import run_data_structures

	
	# Dollar Run Bars
	dollar_run = run_data_structures.get_dollar_run_bars('FILE_PATH', 
	num_prev_bars=3, exp_num_ticks_init=100000)








