

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Sampling &mdash; mlfinlab 0.3.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Fractionally Differentiated Features" href="frac_diff.html" />
    <link rel="prev" title="Labeling" href="labeling.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> mlfinlab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/barriers_to_entry.html">Barriers to Entry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/requirements.html">Requirements</a></li>
</ul>
<p class="caption"><span class="caption-text">Implementations</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="data_structures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_product.html">Multi-Product Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="labeling.html">Labeling</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Sampling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sample-uniqueness">Sample Uniqueness</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sequential-bootstrapping">Sequential Bootstrapping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monte-carlo-experiment">Monte-Carlo Experiment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sample-weights">Sample Weights</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#by-returns-and-average-uniqueness">By Returns and Average Uniqueness</a></li>
<li class="toctree-l3"><a class="reference internal" href="#by-time-decay">By Time Decay</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#research-notebooks">Research Notebooks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sample-uniqueness-and-weights">Sample Uniqueness and Weights</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Sequential Bootstrapping</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="frac_diff.html">Fractionally Differentiated Features</a></li>
</ul>
<p class="caption"><span class="caption-text">Additional Information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../additional_information/contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../additional_information/contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../additional_information/license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">mlfinlab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Sampling</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/implementations/sampling.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sampling">
<span id="implementations-sampling"></span><h1>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h1>
<p>In financial machine learning, samples are not independent. The most part of traditional machine learning algorithms assume that samples are i.i.d, in case of financial machine learning samples are neither identically distributed not indepedent. In this section we will tackle the problem of samples dependency. As you remember, we mostly label our datasets using triple-barrier method. Each label in triple-barrier event has label index and label endtime (t1) which corresponds to time when one of barriers was touched.</p>
<div class="section" id="sample-uniqueness">
<h2>Sample Uniqueness<a class="headerlink" href="#sample-uniqueness" title="Permalink to this headline">¶</a></h2>
<p>Let’s look at example of 3 samples: A, B, C.</p>
<p>Imagine that:</p>
<p>A was generated at <span class="math notranslate nohighlight">\(t_1\)</span> and triggered on <span class="math notranslate nohighlight">\(t_8\)</span></p>
<p>B was generated at <span class="math notranslate nohighlight">\(t_3\)</span> and triggered on <span class="math notranslate nohighlight">\(t_6\)</span></p>
<p>C was generated on <span class="math notranslate nohighlight">\(t_7\)</span> and triggered on <span class="math notranslate nohighlight">\(t_9\)</span></p>
<p>In this case we see that A used information about returns on <span class="math notranslate nohighlight">\([t_1,t_8]\)</span> to generate label-endtime which overlaps with <span class="math notranslate nohighlight">\([t_3, t_6]\)</span> which was used by B, however C didn’t use any returns information which was used by to label other samples. Here we would like to introduce the concept of concurrency.</p>
<p>We say that labels <span class="math notranslate nohighlight">\(y_i\)</span> and <span class="math notranslate nohighlight">\(y_j\)</span> are concurrent at <span class="math notranslate nohighlight">\(t\)</span> if they are a function of at least one common return at <span class="math notranslate nohighlight">\(r_{t-1,t}\)</span></p>
<p>In terms of concurrency label C is the most ‘pure’ as it doesn’t use any piece of information from other labels, while A is the ‘dirtiest’ as it uses information from both B and C. By understanding average label uniqueness you can measure how ‘pure’ your dataset is based on concurrency of labels. We can measure average label uniqueness using get_av_uniqueness_from_triple_barrier function from mlfinlab package.</p>
<p>This function is the orchestrator to derive average sample uniqueness from a dateset labeled by the triple barrier method.</p>
<dl class="function">
<dt id="get_av_uniqueness_from_triple_barrier">
<code class="sig-name descname">get_av_uniqueness_from_triple_barrier</code><span class="sig-paren">(</span><em class="sig-param">triple_barrier_events</em>, <em class="sig-param">close_series</em>, <em class="sig-param">num_threads</em><span class="sig-paren">)</span><a class="headerlink" href="#get_av_uniqueness_from_triple_barrier" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triple_barrier_events</strong> – (data frame) of events from labeling.get_events()</p></li>
<li><p><strong>close_series</strong> – (pd.Series) close prices.</p></li>
<li><p><strong>num_threads</strong> – (int) The number of threads concurrently used by the function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.Series) average uniqueness over event’s lifespan for each index in triple_barrier_events</p>
</dd>
</dl>
</dd></dl>

<p>An example of calculating average uniqueness given that we have already found our barrier events can be seen below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mlfinlab.sampling.concurrent</span> <span class="k">import</span> <span class="n">get_av_uniqueness_from_triple_barrier</span>


<span class="n">barrier_events</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;FILE_PATH&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">close_prices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;FILE_PATH&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>


<span class="n">av_unique</span> <span class="o">=</span> <span class="n">get_av_uniqueness_from_triple_barrier</span><span class="p">(</span><span class="n">barrier_events</span><span class="p">,</span> <span class="n">close_prices</span><span class="o">.</span><span class="n">close</span><span class="p">,</span>
 <span class="n">num_threads</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>We would like to build our model in such a way that it takes into account labels concurrency. In order to do that we need to look at the bootstrapping algorithm of Random Forest.</p>
</div>
<div class="section" id="sequential-bootstrapping">
<h2>Sequential Bootstrapping<a class="headerlink" href="#sequential-bootstrapping" title="Permalink to this headline">¶</a></h2>
<p>The key power of ensemble learning techniques is bagging (which is bootstrapping with replacement). The key idea behind bagging is to randomly choose samples for each decision tree. In this case trees become diverse and by averaging predictions of diverse tress built on randomly selected samples and random subset of features data scientists make the algorithm much less prone to overfit.</p>
<p>However, in our case we would not only like to randomly choose samples but also choose samples which are unique and non-concurrent. But how can we solve this problem? Here comes Sequential Bootstrapping algorithm.</p>
<p>The key idea behind Sequential Bootstrapping is to select samples in such a way that on each iteration we maximize average uniqueness of selected subsamples.</p>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>The core functions behind Sequential Bootstrapping are implemented in mlfinlab and can be seen below:</p>
<p>Snippet 4.3, page 65, Build an Indicator Matrix</p>
<p>Get indicator matrix. The book implementation uses bar_index as input, however there is no explanation how to form it.</p>
<p>We decided that using triple_barrier_events and price bars by analogy with concurrency is the best option.</p>
<dl class="function">
<dt id="get_ind_matrix">
<code class="sig-name descname">get_ind_matrix</code><span class="sig-paren">(</span><em class="sig-param">triple_barrier_events</em>, <em class="sig-param">price_bars</em><span class="sig-paren">)</span><a class="headerlink" href="#get_ind_matrix" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triple_barrier_events</strong> – (pd.DataFrame): triple barrier events from labeling.get_events</p></li>
<li><p><strong>price_bars</strong> – (pd.DataFrame): price bars which were used to form triple barrier events</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(np.array) indicator binary matrix indicating what (price) bars influence the label for each observation</p>
</dd>
</dl>
</dd></dl>

<p>Snippet 4.4. page 65, Compute Average Uniqueness</p>
<p>Average uniqueness from indicator matrix</p>
<dl class="function">
<dt id="get_ind_mat_average_uniqueness">
<code class="sig-name descname">get_ind_mat_average_uniqueness</code><span class="sig-paren">(</span><em class="sig-param">ind_mat</em><span class="sig-paren">)</span><a class="headerlink" href="#get_ind_mat_average_uniqueness" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind_mat</strong> – (np.matrix) indicator binary matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(float) average uniqueness</p>
</dd>
</dl>
</dd></dl>

<p>An adaption of Snippet 4.4. page 65, which returns the indicator matrix element uniqueness.</p>
<dl class="function">
<dt id="get_ind_mat_label_uniqueness">
<code class="sig-name descname">get_ind_mat_label_uniqueness</code><span class="sig-paren">(</span><em class="sig-param">ind_mat</em><span class="sig-paren">)</span><a class="headerlink" href="#get_ind_mat_label_uniqueness" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind_mat</strong> – (np.matrix) indicator binary matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(np.matrix) element uniqueness</p>
</dd>
</dl>
</dd></dl>

<p>Snippet 4.5, Snippet 4.6, page 65, Return Sample from Sequential Bootstrap</p>
<p>Generate a sample via sequential bootstrap.</p>
<p>Note: Moved from pd.DataFrame to np.matrix for performance increase</p>
<dl class="function">
<dt id="seq_bootstrap">
<code class="sig-name descname">seq_bootstrap</code><span class="sig-paren">(</span><em class="sig-param">ind_mat</em>, <em class="sig-param">sample_length=None</em>, <em class="sig-param">warmup_samples=None</em>, <em class="sig-param">compare=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">random_state=np.random.RandomState()</em><span class="sig-paren">)</span><a class="headerlink" href="#seq_bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ind_mat</strong> – (data frame) indicator matrix from triple barrier events</p></li>
<li><p><strong>sample_length</strong> – (int) Length of bootstrapped sample</p></li>
<li><p><strong>warmup_samples</strong> – (list) list of previously drawn samples</p></li>
<li><p><strong>compare</strong> – (boolean) flag to print standard bootstrap uniqueness vs sequential bootstrap uniqueness</p></li>
<li><p><strong>verbose</strong> – (boolean) flag to print updated probabilities on each step</p></li>
<li><p><strong>random_state</strong> – (np.random.RandomState) random state</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(array) of bootstrapped samples indexes</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>An example of Sequential Bootstrap using a a toy example from the book can be seen below.</p>
<p>Consider a set of labels <span class="math notranslate nohighlight">\(\left\{y_i\right\}_{i=0,1,2}\)</span> where:</p>
<p>label <span class="math notranslate nohighlight">\(y_0\)</span> is a function of return <span class="math notranslate nohighlight">\(r_{0,2}\)</span></p>
<p>label <span class="math notranslate nohighlight">\(y_1\)</span> is a function of return <span class="math notranslate nohighlight">\(r_{2,3}\)</span></p>
<p>label <span class="math notranslate nohighlight">\(y_2\)</span> is a function of return <span class="math notranslate nohighlight">\(r_{4,5}\)</span></p>
<p>The first thing we need to do is to build and indicator matrix. Columns of this matrix correspond to samples and rows correspond to price returns timestamps which were used during samples labelling. In our case indicator matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ind_mat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ind_mat</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">ind_mat</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">ind_mat</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>One can use get_ind_matrix method from mlfinlab to build indicator matrix from triple-barrier events.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">triple_barrier_ind_mat</span> <span class="o">=</span> <span class="n">get_ind_matrix</span><span class="p">(</span><span class="n">barrier_events</span><span class="p">)</span>
</pre></div>
</div>
<p>We can get average label uniqueness on indicator matrix using get_ind_mat_average_uniqueness function from mlfinlab.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ind_mat_uniqueness</span> <span class="o">=</span> <span class="n">get_ind_mat_average_uniqueness</span><span class="p">(</span><span class="n">triple_barrier_ind_mat</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s get the first sample average uniqueness (we need to filter out zeros to get unbiased result).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_sample</span> <span class="o">=</span> <span class="n">ind_mat_uniqueness</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">first_sample</span><span class="p">[</span><span class="n">first_sample</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="o">&gt;&gt;</span> <span class="mf">0.26886446886446885</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">av_unique</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;</span> <span class="n">tW</span>    <span class="mf">0.238776</span>
</pre></div>
</div>
<p>As you can see it is quite close to values generated by <strong>get_av_uniqueness_from_triple_barrier</strong> function call.</p>
<p>Let’s move back to our example. In Sequential Bootstrapping algorithm we start with an empty array of samples (<span class="math notranslate nohighlight">\(\phi\)</span>) and loop through all samples to get the probability of chosing the sample based on average uniqueness of reduced indicator matrix constructed from [previously chosen columns] + sample</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="n">length</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">number</span> <span class="n">of</span> <span class="n">samples</span> <span class="n">to</span> <span class="n">bootstrap</span><span class="p">:</span>
    <span class="n">average_uniqueness_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
        <span class="n">previous_columns</span>  <span class="o">=</span> <span class="n">phi</span>
        <span class="n">ind_mat_reduced</span> <span class="o">=</span> <span class="n">ind_mat</span><span class="p">[</span><span class="n">previous_columns</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">average_uniqueness_array</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_ind_mat_average_uniqueness</span><span class="p">(</span><span class="n">ind_mat_reduced</span><span class="p">)</span>
    <span class="o">//</span> <span class="n">normalise</span> <span class="n">so</span> <span class="n">that</span> <span class="n">probabilities</span> <span class="nb">sum</span> <span class="n">up</span> <span class="n">to</span> <span class="mi">1</span>
    <span class="n">probability_array</span> <span class="o">=</span> <span class="n">average_uniqueness_array</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">average_uniqueness_array</span><span class="p">)</span>
    <span class="n">chosen_sample</span> <span class="o">=</span> <span class="n">random_choice</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">probability</span> <span class="o">=</span> <span class="n">probability_array</span><span class="p">)</span>
    <span class="n">phi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chosen_sample</span><span class="p">)</span>
</pre></div>
</div>
<p>For peformance increase we optimized and parallesied for-loop using numba, which corresponds to bootstrap_loop_run function.</p>
<p>Not let’s finish the example:</p>
<p>To be as close to mlfinlab implementation let’s convert ind_mat to numpy matrix</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ind_mat</span> <span class="o">=</span> <span class="n">ind_mat</span><span class="o">.</span><span class="n">values</span>
</pre></div>
</div>
<p>1st iteration:</p>
<p>On the first step all labels will have equal probalities as average uniqueness of matrix with 1 column is 1. Say we have chosen 1 on the first step</p>
<p>2nd iteration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Sample chosen from the 2st step</span>
<span class="n">uniqueness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="n">ind_mat_reduced</span> <span class="o">=</span> <span class="n">ind_mat</span><span class="p">[:,</span> <span class="n">phi</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">label_uniqueness</span> <span class="o">=</span> <span class="n">get_ind_mat_average_uniqueness</span><span class="p">(</span><span class="n">ind_mat_reduced</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># The last value corresponds to appended i</span>
    <span class="n">uniqueness_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">label_uniqueness</span><span class="p">[</span><span class="n">label_uniqueness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="n">prob_array</span> <span class="o">=</span> <span class="n">uniqueness_array</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">uniqueness_array</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">prob_array</span>
  <span class="o">&gt;&gt;</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.35714285714285715</span><span class="p">,</span> <span class="mf">0.21428571428571427</span><span class="p">,</span> <span class="mf">0.42857142857142855</span><span class="p">],</span>
<span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
</pre></div>
</div>
<p>Probably the second chosen feature will be 2 (prob_array[2] = 0.42857 which is the largest probability). As you can see up till now the algorithm has chosen two the least concurrent labels (1 and 2)</p>
<p>3rd iteration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">uniqueness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="n">ind_mat_reduced</span> <span class="o">=</span> <span class="n">ind_mat</span><span class="p">[:,</span> <span class="n">phi</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">label_uniqueness</span> <span class="o">=</span> <span class="n">get_ind_mat_average_uniqueness</span><span class="p">(</span><span class="n">ind_mat_reduced</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">uniqueness_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">label_uniqueness</span><span class="p">[</span><span class="n">label_uniqueness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="n">prob_array</span> <span class="o">=</span> <span class="n">uniqueness_array</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">uniqueness_array</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">prob_array</span>
  <span class="o">&gt;&gt;</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.45454545454545453</span><span class="p">,</span> <span class="mf">0.2727272727272727</span><span class="p">,</span> <span class="mf">0.2727272727272727</span><span class="p">],</span>
<span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
</pre></div>
</div>
<p>Sequential Bootstrapping tries to minimise the probability of repeated samples so as you can see the most probable sample would be 0 with 1 and 2 already selected.</p>
<p>4th iteration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">uniqueness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="n">ind_mat_reduced</span> <span class="o">=</span> <span class="n">ind_mat</span><span class="p">[:,</span> <span class="n">phi</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">label_uniqueness</span> <span class="o">=</span> <span class="n">get_ind_mat_average_uniqueness</span><span class="p">(</span><span class="n">ind_mat_reduced</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">uniqueness_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">label_uniqueness</span><span class="p">[</span><span class="n">label_uniqueness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="n">prob_array</span> <span class="o">=</span> <span class="n">uniqueness_array</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">uniqueness_array</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">prob_array</span>
  <span class="o">&gt;&gt;</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.32653061224489793</span><span class="p">,</span> <span class="mf">0.3061224489795918</span><span class="p">,</span> <span class="mf">0.36734693877551017</span><span class="p">],</span>
<span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
</pre></div>
</div>
<p>The most probable sample would be 2 in this case</p>
<p>After 4 steps of sequential bootstrapping our drawn samples are [1,2,0,2]</p>
<p>Let’s see how this example is solved by mlfinlab implementation. To reproduce that:</p>
<ol class="arabic simple">
<li><p>we need to set warmup to [1], which corresponds to phi = [1] on the first step</p></li>
<li><p>verbose = True to print updated probabilities</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">seq_bootstrap</span><span class="p">(</span><span class="n">ind_mat</span><span class="p">,</span> <span class="n">sample_length</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">warmup_samples</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="p">[</span><span class="mf">0.33333333</span> <span class="mf">0.33333333</span> <span class="mf">0.33333333</span><span class="p">]</span>
<span class="o">&gt;&gt;</span> <span class="p">[</span><span class="mf">0.35714286</span> <span class="mf">0.21428571</span> <span class="mf">0.42857143</span><span class="p">]</span>
<span class="o">&gt;&gt;</span> <span class="p">[</span><span class="mf">0.45454545</span> <span class="mf">0.27272727</span> <span class="mf">0.27272727</span><span class="p">]</span>
<span class="o">&gt;&gt;</span> <span class="p">[</span><span class="mf">0.32653061</span> <span class="mf">0.30612245</span> <span class="mf">0.36734694</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span>
<span class="o">&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>As you can see the first 2 iterations of algorithm yield the same probabilities, however sometimes the algorithm randomly chooses not the 2 sample on 2nd iteration that is why further probabilities are different from the example above. However, if you repeat the process several times you’ll see that on average drawn sample equal to the one from the example</p>
</div>
<div class="section" id="monte-carlo-experiment">
<h3>Monte-Carlo Experiment<a class="headerlink" href="#monte-carlo-experiment" title="Permalink to this headline">¶</a></h3>
<p>Let’s see how sequential bootstrapping increases average label uniqueness on this example by generating 3 samples using sequential bootstrapping and 3 samples using standard random choise, repeat the experiment 10000 times and record corresponding label uniqueness in each experiment</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">standard_unq_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># Array of random sampling uniqueness</span>
<span class="n">seq_unq_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># Array of Sequential Bootstapping uniqueness</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10000</span><span class="p">):</span>
    <span class="n">bootstrapped_samples</span> <span class="o">=</span> <span class="n">seq_bootstrap</span><span class="p">(</span><span class="n">ind_mat</span><span class="p">,</span> <span class="n">sample_length</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">random_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">random_unq</span> <span class="o">=</span> <span class="n">get_ind_mat_average_uniqueness</span><span class="p">(</span><span class="n">ind_mat</span><span class="p">[:,</span> <span class="n">random_samples</span><span class="p">])</span>
    <span class="n">random_unq_mean</span> <span class="o">=</span> <span class="n">random_unq</span><span class="p">[</span><span class="n">random_unq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="n">sequential_unq</span> <span class="o">=</span> <span class="n">get_ind_mat_average_uniqueness</span><span class="p">(</span><span class="n">ind_mat</span><span class="p">[:,</span> <span class="n">bootstrapped_samples</span><span class="p">])</span>
    <span class="n">sequential_unq_mean</span> <span class="o">=</span> <span class="n">sequential_unq</span><span class="p">[</span><span class="n">sequential_unq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="n">standard_unq_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_unq_mean</span>
    <span class="n">seq_unq_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sequential_unq_mean</span>
</pre></div>
</div>
<p>KDE plots of label uniqueness support the fact that sequential bootstrapping gives higher average label uniqueness</p>
<a class="reference internal image-reference" href="../_images/monte_carlo_bootstrap.png"><img alt="../_images/monte_carlo_bootstrap.png" class="align-center" src="../_images/monte_carlo_bootstrap.png" style="width: 475.8px; height: 327.6px;" /></a>
<p>We can compare average label uniqueness using sequential bootstrap vs label uniqueness using standard random sampling by setting compare parameter to True. We have massively increased the performance of Sequential Bootstrapping which was described in the book. For comparison generating 50 samples from 8000 barrier-events would take 3 days, we have reduced time to 10-12 seconds which decreases by increasing number of CPUs.</p>
<p>Let’s apply sequential bootstrapping to our full data set and draw 50 samples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Standard</span> <span class="n">uniqueness</span><span class="p">:</span> <span class="mf">0.9465875370919882</span>
<span class="n">Sequential</span> <span class="n">uniqueness</span><span class="p">:</span> <span class="mf">0.9913169319826338</span>
</pre></div>
</div>
<p>Sometimes you would see that standard bootstrapping gives higher uniqueness, however as it was shown in Monte-Carlo example, on average Sequential Bootstrapping algorithm has higher average uniqueness.</p>
</div>
</div>
<div class="section" id="sample-weights">
<h2>Sample Weights<a class="headerlink" href="#sample-weights" title="Permalink to this headline">¶</a></h2>
<p>mlfinlab supports two methods of applying sample weights. The first is weighting an observation based on its given return as well as average uniqueness. The second is weighting an observation based on a time decay.</p>
<div class="section" id="by-returns-and-average-uniqueness">
<h3>By Returns and Average Uniqueness<a class="headerlink" href="#by-returns-and-average-uniqueness" title="Permalink to this headline">¶</a></h3>
<p>The following function utilizes a samples average uniqueness and its return to compute sample weights:</p>
<dl class="function">
<dt id="get_weights_by_return">
<code class="sig-name descname">get_weights_by_return</code><span class="sig-paren">(</span><em class="sig-param">triple_barrier_events</em>, <em class="sig-param">close_series</em>, <em class="sig-param">num_threads=5</em><span class="sig-paren">)</span><a class="headerlink" href="#get_weights_by_return" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triple_barrier_events</strong> – (data frame) of events from labeling.get_events()</p></li>
<li><p><strong>close_series</strong> – (pd.Series) close prices</p></li>
<li><p><strong>num_threads</strong> – (int) the number of threads concurrently used by the function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.Series) of sample weights based on number return and concurrency</p>
</dd>
</dl>
</dd></dl>

<p>This function can be utilized as shown below assuming we have already found our barrier events</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mlfinlab.sampling.attribution</span> <span class="k">import</span> <span class="n">get_weights_by_return</span>


<span class="n">barrier_events</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;FILE_PATH&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">close_prices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;FILE_PATH&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>


<span class="n">sample_weights</span> <span class="o">=</span> <span class="n">get_weights_by_return</span><span class="p">(</span><span class="n">barrier_events</span><span class="p">,</span> <span class="n">close_prices</span><span class="o">.</span><span class="n">close</span><span class="p">,</span>
 <span class="n">num_threads</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="by-time-decay">
<h3>By Time Decay<a class="headerlink" href="#by-time-decay" title="Permalink to this headline">¶</a></h3>
<p>The following function assigns sample weights using a time decay factor</p>
<dl class="function">
<dt id="get_weights_by_time_decay">
<code class="sig-name descname">get_weights_by_time_decay</code><span class="sig-paren">(</span><em class="sig-param">triple_barrier_events</em>, <em class="sig-param">close_series</em>, <em class="sig-param">num_threads=5</em>, <em class="sig-param">decay=1</em><span class="sig-paren">)</span><a class="headerlink" href="#get_weights_by_time_decay" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triple_barrier_events</strong> – (data frame) of events from labeling.get_events()</p></li>
<li><p><strong>close_series</strong> – (pd.Series) close prices</p></li>
<li><p><strong>num_threads</strong> – (int) the number of threads concurrently used by the function.</p></li>
<li><p><strong>decay</strong> – (int) decay factor
- decay = 1 means there is no time decay
- 0 &lt; decay &lt; 1 means that weights decay linearly over time, but every observation still receives a strictly positive weight, regadless of how old
- decay = 0 means that weights converge linearly to zero, as they become older
- decay &lt; 0 means that the oldes portion c of the observations receive zero weight (i.e they are erased from memory)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p>This function can be utilized as shown below assuming we have already found our barrier events</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mlfinlab.sampling.attribution</span> <span class="k">import</span> <span class="n">get_weights_by_time_decay</span>


<span class="n">barrier_events</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;FILE_PATH&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">close_prices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;FILE_PATH&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>


<span class="n">sample_weights</span> <span class="o">=</span>  <span class="n">get_weights_by_time_decay</span><span class="p">(</span><span class="n">barrier_events</span><span class="p">,</span> <span class="n">close_prices</span><span class="o">.</span><span class="n">close</span><span class="p">,</span>
<span class="n">num_threads</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="research-notebooks">
<h2>Research Notebooks<a class="headerlink" href="#research-notebooks" title="Permalink to this headline">¶</a></h2>
<p>The following research notebooks can be used to better understand the previously discussed sampling methods</p>
<div class="section" id="sample-uniqueness-and-weights">
<h3>Sample Uniqueness and Weights<a class="headerlink" href="#sample-uniqueness-and-weights" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/hudson-and-thames/research/blob/master/Chapter4/Chapter4_Exercises.ipynb">Sample Uniqueness and Weights</a></p>
</div>
<div class="section" id="id2">
<h3>Sequential Bootstrapping<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/hudson-and-thames/research/blob/master/Chapter4/Sequential_Bootstrapping.ipynb">Sequential Bootstrapping</a></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="frac_diff.html" class="btn btn-neutral float-right" title="Fractionally Differentiated Features" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="labeling.html" class="btn btn-neutral float-left" title="Labeling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Hudson &amp; Thames

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>