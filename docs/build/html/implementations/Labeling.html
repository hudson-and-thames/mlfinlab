

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Labeling &mdash; mlfinlab 0.3.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sampling" href="sampling.html" />
    <link rel="prev" title="Filters" href="filters.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> mlfinlab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/barriers_to_entry.html">Barriers to Entry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/requirements.html">Requirements</a></li>
</ul>
<p class="caption"><span class="caption-text">Implementations</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="data_structures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi_product.html">Multi-Product Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">Filters</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Labeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#triple-barrier-method">Triple-Barrier Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="#meta-labeling">Meta-Labeling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#how-to-use-meta-labeling">How to use Meta-Labeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#model-architecture">Model Architecture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#research-notebooks">Research Notebooks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Triple-Barrier Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Meta-Labeling</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="frac_diff.html">Fractionally Differentiated Features</a></li>
</ul>
<p class="caption"><span class="caption-text">Additional Information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../additional_information/contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../additional_information/contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../additional_information/license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">mlfinlab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Labeling</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/implementations/labeling.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="labeling">
<span id="implementations-labeling"></span><h1>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h1>
<p>The primary labeling method used in financial academia is the fixed-time horizon method. While ubiquitous, this method has many faults which are remedied by the triple-barrier method discussed below. The triple-barrier method can be extended to incorporate meta-labeling which will also be demonstrated and discussed below.</p>
<div class="section" id="triple-barrier-method">
<h2>Triple-Barrier Method<a class="headerlink" href="#triple-barrier-method" title="Permalink to this headline">¶</a></h2>
<p>The idea behind the triple-barrier method is that we have three barriers: an upper barrier, a lower barrier, and a vertical barrier. The upper barrier represents the threshold an observation’s return needs to reach in order to be considered a buying opportunty (a label of 1), the lower barrier represents the threshold an observation’s return needs to reach in order to be considered a selling opportunity (a label of -1), and the vertical barrier represents the amount of time an observation has to reach its given return in either direction before it is given a label of 0. This concept can be better understood visually and is shown in the figure below taken from Advances in Financial Machine Learning (<a class="reference external" href="https://www.wiley.com/en-us/Advances+in+Financial+Machine+Learning-p-9781119482086">reference</a>):</p>
<a class="reference internal image-reference" href="../_images/triple_barrier.png"><img alt="../_images/triple_barrier.png" class="align-center" src="../_images/triple_barrier.png" style="width: 468.0px; height: 346.0px;" /></a>
<p>One of the major faults with the fixed-time horizon method is that observations are given a label with respect to a certrain threshold after a fixed interval regardless of their respective volatilities. In other words, the expected returns of every observation are treated equally regardless of the associated risk. The triple-barrier method tackles this issue by dynamically setting the upper and lower barriers for each observation based on their given volatilities.</p>
</div>
<div class="section" id="meta-labeling">
<h2>Meta-Labeling<a class="headerlink" href="#meta-labeling" title="Permalink to this headline">¶</a></h2>
<p>Advances in Financial Machine Learning, Chapter 3, page 50. Reads:</p>
<p>“Suppose that you have a model for setting the side of the bet (long or short). You just need to learn the size of that bet, which includes the possibility of no bet at all (zero size). This is a situation that practitioners face regularly. We often know whether we want to buy or sell a product, and the only remaining question is how much money we should risk in such a bet. We do not want the ML algorithm to learn the side, just to tell us what is the appropriate size. At this point, it probably does not surprise you to hear that no book or paper has so far discussed this common problem. Thankfully, that misery ends here.””</p>
<p>I call this problem meta-labeling because we want to build a secondary ML model that learns how to use a primary exogenous model.</p>
<p>The ML algorithm will be trained to decide whether to take the bet or pass, a purely binary prediction. When the predicted label is 1, we can use the probability of this secondary prediction to derive the size of the bet, where the side (sign) of the position has been set by the primary model.</p>
<div class="section" id="how-to-use-meta-labeling">
<h3>How to use Meta-Labeling<a class="headerlink" href="#how-to-use-meta-labeling" title="Permalink to this headline">¶</a></h3>
<p>Binary classification problems present a trade-off between type-I errors (false positives) and type-II errors (false negatives). In general, increasing the true positive rate of a binary classifier will tend to increase its false positive rate. The receiver operating characteristic (ROC) curve of a binary classifier measures the cost of increasing the true positive rate, in terms of accepting higher false positive rates.</p>
<a class="reference internal image-reference" href="../_images/confusion_matrix.png"><img alt="../_images/confusion_matrix.png" class="align-center" src="../_images/confusion_matrix.png" style="width: 461.99999999999994px; height: 840.0px;" /></a>
<p>The image illustrates the so-called “confusion matrix.” On a set of observations, there are items that exhibit a condition (positives, left rectangle), and items that do not exhibit a condition (negative, right rectangle). A binary classifier predicts that some items exhibit the condition (ellipse), where the TP area contains the true positives and the TN area contains the true negatives. This leads to two kinds of errors: false positives (FP) and false negatives (FN). “Precision” is the ratio between the TP area and the area in the ellipse. “Recall” is the ratio between the TP area and the area in the left rectangle. This notion of recall (aka true positive rate) is in the context of classification problems, the analogous to “power” in the context of hypothesis testing. “Accuracy” is the sum of the TP and TN areas divided by the overall set of items (square). In general, decreasing the FP area comes at a cost of increasing the FN area, because higher precision typically means fewer calls, hence lower recall. Still, there is some combination of precision and recall that maximizes the overall efficiency of the classifier. The F1-score measures the efficiency of a classifier as the harmonic average between precision and recall.</p>
<p><strong>Meta-labeling is particularly helpful when you want to achieve higher F1-scores</strong>. First, we build a model that achieves high recall, even if the precision is not particularly high. Second, we correct for the low precision by applying meta-labeling to the positives predicted by the primary model.</p>
<p>Meta-labeling will increase your F1-score by filtering out the false positives, where the majority of positives have already been identified by the primary model. Stated differently, the role of the secondary ML algorithm is to determine whether a positive from the primary (exogenous) model is true or false. It is not its purpose to come up with a betting opportunity. Its purpose is to determine whether we should act or pass on the opportunity that has been presented.</p>
<p>Meta-labeling is a very powerful tool to have in your arsenal, for four additional reasons. <strong>First</strong>, ML algorithms are often criticized as black boxes. Meta-labeling allows you to build an ML system on top of a white box (like a fundamental model founded on economic theory). This ability to transform a fundamental model into an ML model should make meta-labeling particularly useful to “quantamental” firms. <strong>Second</strong>, the effects of overfitting are limited when you apply metalabeling, because ML will not decide the side of your bet, only the size. <strong>Third</strong>, by decoupling the side prediction from the size prediction, meta-labeling enables sophisticated strategy structures. For instance, consider that the features driving a rally may differ from the features driving a sell-off. In that case, you may want to develop an ML strategy exclusively for long positions, based on the buy recommendations of a primary model, and an ML strategy exclusively for short positions, based on the sell recommendations of an entirely different primary model. <strong>Fourth</strong>, achieving high accuracy on small bets and low accuracy on large bets will ruin you. As important as identifying good opportunities is to size them properly, so it makes sense to develop an ML algorithm solely focused on getting that critical decision (sizing) right. We will retake this fourth point in Chapter 10. In my experience, meta-labeling ML models can deliver more robust and reliable outcomes than standard labeling models.</p>
</div>
<div class="section" id="model-architecture">
<h3>Model Architecture<a class="headerlink" href="#model-architecture" title="Permalink to this headline">¶</a></h3>
<p>The following image explains the model architecture. The <strong>first</strong> step is to train a primary model (binary classification). <strong>Second</strong> a threshold level is determined at which the primary model has a high recall, in the coded example you will find that 0.30 is a good threshold, ROC curves could be used to help determine a good level. <strong>Third</strong> the features from the first model are concatenated with the predictions from the first model, into a new feature set for the secondary model. Meta Labels are used as the target variable in the second model. Now fit the second model. <strong>Fourth</strong> the prediction from the secondary model is combined with the prediction from the primary model and only where both are true, is your final prediction true. I.e. if your primary model predicts a 3 and your secondary model says you have a high probability of the primary model being correct, is your final prediction a 3, else not 3.</p>
<a class="reference internal image-reference" href="../_images/meta_labeling_architecture.png"><img alt="../_images/meta_labeling_architecture.png" class="align-center" src="../_images/meta_labeling_architecture.png" style="width: 527.1px; height: 475.99999999999994px;" /></a>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>The following functions are used for the triple-barrier method which works in tandem with meta-labeling.</p>
<p>Snippet 3.1, page 44, Daily Volatility Estimates</p>
<p>Computes the daily volatility at intraday estimation points.</p>
<p>In practice we want to set profit taking and stop-loss limits that are a function of the risks involved
in a bet. Otherwise, sometimes we will be aiming too high (tao ≫ sigma_t_i,0), and sometimes too low
(tao ≪ sigma_t_i,0 ), considering the prevailing volatility.</p>
<p>Snippet 3.1 computes the daily volatility
at intraday estimation points, applying a span of lookback days to an exponentially weighted moving
standard deviation.</p>
<p>See the pandas documentation for details on the pandas.Series.ewm function.</p>
<p>Note: This function is used to compute dynamic thresholds for profit taking and stop loss limits.</p>
<dl class="function">
<dt id="get_daily_vol">
<code class="sig-name descname">get_daily_vol</code><span class="sig-paren">(</span><em class="sig-param">close</em>, <em class="sig-param">lookback=100</em><span class="sig-paren">)</span><a class="headerlink" href="#get_daily_vol" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>close</strong> – Closing prices</p></li>
<li><p><strong>lookback</strong> – lookback period to compute volatility</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>series of daily volatility value</p>
</dd>
</dl>
</dd></dl>

<p>Snippet 3.4 page 49, Adding a Vertical Barrier</p>
<p>For each index in t_events, it finds the timestamp of the next price bar at or immediately after
a number of days num_days. This vertical barrier can be passed as an optional argument t1 in get_events.</p>
<p>This function creates a series that has all the timestamps of when the vertical barrier would be reached.</p>
<dl class="function">
<dt id="add_vertical_barrier">
<code class="sig-name descname">add_vertical_barrier</code><span class="sig-paren">(</span><em class="sig-param">t_events</em>, <em class="sig-param">close</em>, <em class="sig-param">num_days=0</em>, <em class="sig-param">num_hours=0</em>, <em class="sig-param">num_minutes=0</em>, <em class="sig-param">num_seconds=0</em><span class="sig-paren">)</span><a class="headerlink" href="#add_vertical_barrier" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_events</strong> – (series) series of events (symmetric CUSUM filter)</p></li>
<li><p><strong>close</strong> – (series) close prices</p></li>
<li><p><strong>num_days</strong> – (int) number of days to add for vertical barrier</p></li>
<li><p><strong>num_hours</strong> – (int) number of hours to add for vertical barrier</p></li>
<li><p><strong>num_minutes</strong> – (int) number of minutes to add for vertical barrier</p></li>
<li><p><strong>num_seconds</strong> – (int) number of seconds to add for vertical barrier</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(series) timestamps of vertical barriers</p>
</dd>
</dl>
</dd></dl>

<p>Snippet 3.6 page 50, Getting the Time of the First Touch, with Meta Labels</p>
<p>This function is orchestrator to meta-label the data, in conjunction with the Triple Barrier Method.</p>
<dl class="function">
<dt id="get_events">
<code class="sig-name descname">get_events</code><span class="sig-paren">(</span><em class="sig-param">close</em>, <em class="sig-param">t_events</em>, <em class="sig-param">pt_sl</em>, <em class="sig-param">target</em>, <em class="sig-param">min_ret</em>, <em class="sig-param">num_threads</em>, <em class="sig-param">vertical_barrier_times=False</em>, <em class="sig-param">side_prediction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#get_events" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>close</strong> – (series) Close prices</p></li>
<li><p><strong>t_events</strong> – (series) of t_events. These are timestamps that will seed every triple barrier.
These are the timestamps selected by the sampling procedures discussed in Chapter 2, Section 2.5. Eg: CUSUM Filter</p></li>
<li><p><strong>pt_sl</strong> – (2 element array) element 0, indicates the profit taking level; element 1 is stop loss level. A non-negative float that sets the width of the two barriers.
A 0 value means that the respective horizontal barrier (profit taking and/or stop loss) will be disabled.</p></li>
<li><p><strong>target</strong> – (series) of values that are used (in conjunction with pt_sl) to determine the width of the barrier. In this program this is daily volatility series.</p></li>
<li><p><strong>min_ret</strong> – (float) The minimum target return required for running a triple barrier search.</p></li>
<li><p><strong>num_threads</strong> – (int) The number of threads concurrently used by the function.</p></li>
<li><p><strong>vertical_barrier_times</strong> – (series) A pandas series with the timestamps of the vertical barriers. We pass a False when we want to disable vertical barriers.</p></li>
<li><p><strong>side_prediction</strong> – (series) Side of the bet (long/short) as decided by the primary model</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>(data frame) of events
events.index is event’s starttime</p>
<p>events[‘t1’] is event’s endtime</p>
<p>events[‘trgt’] is event’s target</p>
<p>events[‘side’] (optional) implies the algo’s position side</p>
</p>
</dd>
</dl>
</dd></dl>

<p>Snippet 3.7, page 51, Labeling for Side &amp; Size with Meta Labels</p>
<p>Compute event’s outcome (including side information, if provided).
events is a DataFrame where:</p>
<p>Now the possible values for labels in out[‘bin’] are {0,1}, as opposed to whether to take the bet or pass,
a purely binary prediction. When the predicted label the previous feasible values {−1,0,1}.
The ML algorithm will be trained to decide is 1, we can use the probability of this secondary prediction
to derive the size of the bet, where the side (sign) of the position has been set by the primary model.</p>
<dl class="function">
<dt id="get_bins">
<code class="sig-name descname">get_bins</code><span class="sig-paren">(</span><em class="sig-param">triple_barrier_events</em>, <em class="sig-param">close</em><span class="sig-paren">)</span><a class="headerlink" href="#get_bins" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triple_barrier_events</strong> – <p>(data frame)</p>
<p>events.index is event’s starttime</p>
<p>events[‘t1’] is event’s endtime</p>
<p>events[‘trgt’] is event’s target</p>
<p>events[‘side’] (optional) implies the algo’s position side</p>
<p>Case 1: (‘side’ not in events): bin in (-1,1) &lt;-label by price action</p>
<p>Case 2: (‘side’ in events): bin in (0,1) &lt;-label by pnl (meta-labeling)</p>
</p></li>
<li><p><strong>close</strong> – (series) close prices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(data frame) of meta-labeled events</p>
</dd>
</dl>
</dd></dl>

<p>Snippet 3.8 page 54</p>
<p>This function recursively eliminates rare observations.</p>
<dl class="function">
<dt id="drop_labels">
<code class="sig-name descname">drop_labels</code><span class="sig-paren">(</span><em class="sig-param">events</em>, <em class="sig-param">min_pct=.05</em><span class="sig-paren">)</span><a class="headerlink" href="#drop_labels" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>events</strong> – (data frame) events</p></li>
<li><p><strong>min_pct</strong> – (float) a fraction used to decide if the observation occurs less than that fraction</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(data frame) of event</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Suppose we use a mean reverting strategy as our primary model, giving each observation a label of 1 or -1.
We can then use meta-labeling to act as a filter for the bets of our primary model.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mlfinlab</span> <span class="k">as</span> <span class="nn">ml</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read in data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;FILE_PATH&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Assuming we have a pandas series with the timestamps of our observations and their respective labels given by the primary model, the process to generate meta-labels goes as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute daily volatility</span>
<span class="n">daily_vol</span> <span class="o">=</span> <span class="n">ml</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">get_daily_vol</span><span class="p">(</span><span class="n">close</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">],</span> <span class="n">lookback</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

<span class="c1"># Apply Symmetric CUSUM Filter and get timestamps for events</span>
<span class="c1"># Note: Only the CUSUM filter needs a point estimate for volatility</span>
<span class="n">cusum_events</span> <span class="o">=</span> <span class="n">ml</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">cusum_filter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">],</span>
 <span class="n">threshold</span><span class="o">=</span><span class="n">daily_vol</span><span class="p">[</span><span class="s1">&#39;2011-09-01&#39;</span><span class="p">:</span><span class="s1">&#39;2018-01-01&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Compute vertical barrier</span>
<span class="n">vertical_barriers</span> <span class="o">=</span> <span class="n">ml</span><span class="o">.</span><span class="n">labeling</span><span class="o">.</span><span class="n">add_vertical_barrier</span><span class="p">(</span><span class="n">t_events</span><span class="o">=</span><span class="n">cusum_events</span><span class="p">,</span>
 <span class="n">close</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">],</span> <span class="n">num_days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Once we have computed our daily volatility along with our vertical time barriers and have downsampled our series using the CUSUM filter, we can use the triple-barrier method to compute our meta-labels by passing in the side predicted by the primary model.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pt_sl</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">min_ret</span> <span class="o">=</span> <span class="mf">0.005</span>
<span class="n">triple_barrier_events</span> <span class="o">=</span> <span class="n">ml</span><span class="o">.</span><span class="n">labeling</span><span class="o">.</span><span class="n">get_events</span><span class="p">(</span><span class="n">close</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">],</span>
                                       <span class="n">t_events</span><span class="o">=</span><span class="n">cusum_events</span><span class="p">,</span>
                                       <span class="n">pt_sl</span><span class="o">=</span><span class="n">pt_sl</span><span class="p">,</span>
                                       <span class="n">target</span><span class="o">=</span><span class="n">daily_vol</span><span class="p">,</span>
                                       <span class="n">min_ret</span><span class="o">=</span><span class="n">min_ret</span><span class="p">,</span>
                                       <span class="n">num_threads</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                       <span class="n">vertical_barrier_times</span><span class="o">=</span><span class="n">vertical_barriers</span><span class="p">,</span>
                                       <span class="n">side_prediction</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;side&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>As can be seen above, we have scaled our lower barrier and set our minimum return to 0.005.</p>
<p>Meta-labels can then be computed using the time that each observation touched its respective barrier</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">meta_labels</span> <span class="o">=</span> <span class="n">ml</span><span class="o">.</span><span class="n">labeling</span><span class="o">.</span><span class="n">get_bins</span><span class="p">(</span><span class="n">triple_barrier_events</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="research-notebooks">
<h2>Research Notebooks<a class="headerlink" href="#research-notebooks" title="Permalink to this headline">¶</a></h2>
<p>The following research notebooks can be used to better understand the triple-barrier method and meta-labeling</p>
<div class="section" id="id1">
<h3>Triple-Barrier Method<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/hudson-and-thames/research/blob/master/Chapter3/2019-03-06_JJ_Trend-Follow-Question.ipynb">Trend Follow Question</a></p>
<p><a class="reference external" href="https://github.com/hudson-and-thames/research/blob/master/Chapter3/2019-03-09_AS_BBand-Question.ipynb">Bollinger band Question</a></p>
</div>
<div class="section" id="id2">
<h3>Meta-Labeling<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/hudson-and-thames/research/blob/master/Chapter3/2019-03-06_JJ_Meta-Labels-MNIST.ipynb">Meta Labeling MNIST</a></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sampling.html" class="btn btn-neutral float-right" title="Sampling" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="filters.html" class="btn btn-neutral float-left" title="Filters" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Hudson &amp; Thames

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>